[Джерело](https://www.atlassian.com/ru/git/tutorials/what-is-version-control)

# Version Control System - GIT
Контроль версій, також відомий як керування вихідним кодом, - це практика відстеження змін програмного коду та керування ними. Системи контролю версій – це програмні інструменти, які допомагають командам розробників керувати змінами у вихідному коді з часом.

Програмне забезпечення контролю версій відстежує всі зміни, що вносяться в код, у спеціальній базі даних. При виявленні помилки розробники можуть повернутися назад і виконати порівняння з попередніми версіями коду для виправлення помилок, зводячи до мінімуму проблеми для всіх учасників команди.
<hr />


## Розгалуження та модель GIT-flow
Git гілки - це елемент повсякденного процесу розробки. По суті гілки в Git є вказівником на знімок змін.
* Якщо потрібно додати нову можливість або виправити помилку (незначну або серйозну), ви створюєте нову гілку, в якій розміщуватимуться ці зміни.
* Розробка в окремих гілках не тільки дозволяє працювати над ними паралельно, але й запобігає попаданню сумнівного коду до головної галузі main.
* Замість копіювати файли з каталогу в каталог, Git зберігає гілку у вигляді посилання на комміт.
* Гілка є окремим напрямом розробки. Гілки виступають як абстрактне уявлення для процесу редагування/індексації/комміту. Можна розглядати їх як спосіб запросити новий робочий каталог, розділ проіндексованих файлів та історію проекту. Нові комміти записуються в історію поточної гілки, що призводить до утворення роздоріжжя в історії проекту.


[Gitflow](https://www.atlassian.com/ru/git/tutorials/comparing-workflows/gitflow-workflow) - це лише методика роботи з Git; у ній визначається, які види гілок необхідні проекту та як виконувати злиття між ними.

<hr />


## Початок роботи
1. Створюємо новий проект на [gitlab.com](https://gitlab.com/)
2. Змінюємо default branch на "master" якщо необхідно.
3. ```git clone <repo>``` де ```<repo>``` - спеціальне посилання для клонування на ваш репозиторій.
4. Створюємо branch ``develop`` від головної гілки (master або main) і робимо пуш в репозиторій.
5. Конфігуруємо налаштування для "master" і "develop"
<hr />


## Перевірка репозиторію

## ```git status```
[Посилання](https://git-scm.com/docs/git-status)

Показує статус робочого дерева

## ```git log```
[Посилання](https://git-scm.com/docs/git-log)

Показує логи коммітів. Наприклад "git log --oneline"
<hr />


## Створення гілок та перемикання між ними

## ```git branch```
[Посилання](https://git-scm.com/docs/git-branch)

```git branch``` - виводить у термінал список усіх гілок
```git branch <branch_name>``` - створює нову гілку з ім'ям *branch_name* у локальному репозиторії

#### Опції
* ``--d`` або ``---delete``` - видаляє локальну гілку
* ``--r`` або ``---remotes`` - разом з ``--d`` видаляє гілку з віддаленого репозиторію
* ```-m``` або ``---move`` - перейменовує гілку

```
     git branch -m <new_name>
     git branch -m <old_name> <new_name>

```

## ```git checkout```

[Посилання](https://git-scm.com/docs/git-checkout)

Здійснює перехід в іншу гілку – оновлює файли у робочій області, щоб вони відповідали версії у вказаній гілці.

```git checkout <branch_name>```

#### Опції
* ```-b``` - створює нову гілку і переходить у неї


```git branch -b <branch_name>```

the same as
   ````
   git branch <branch_name>
   git checkout <branch_name>
   ````
<hr />

## Збереження змін

## ```git add```

[Посилання](https://git-scm.com/docs/git-add)

Додає вміст файлу до індексу.

```git add <directory>```
```git add.```


"Три дерева" - три внутрішні системи управління станом у Git - структури даних на основі вузлів та покажчиків, які Git використовує для відстеження історії внесення правок.

### Робочий каталог

Це дерево синхронізується з локальною файловою системою і відображає безпосередні зміни, внесені до вмісту файлів та каталогів.

### Розділ проіндексованих файлів

* Це спеціальна проміжна область, у якій зберігаються зміни файлів по дорозі від робочої директорії до репозиторію.
* Це дерево відстежує зміни робочого каталогу, які були додані за допомогою команди git add для збереження в наступному коміті.
* При виконанні комміту до нього потрапляють лише ті зміни, які були додані до індексу.

### Історія коммітів
Останнє дерево – історія коммітів. Команда git commit додає зміни до постійного знімка, який знаходиться в історії коммітів. Цей знімок також включає стан розділу проіндексованих файлів на момент виконання коміту.

### HEAD в Git
HEAD – це покажчик на коміт у вашому репозиторії, який стане батьком наступного комміту.


## ```git commit```
[Посилання](https://git-scm.com/docs/git-commit)

Записує індексовані зміни до репозиторію

```git commit``` - Записує зміни до репозиторію і відкриває текстовий редактор для повідомлення комміту ([vim](https://cs14.pikabu.ru/post_img/2021/09/04/5/1630736603193480924.webp))

#### Опції
* ```-a'`` або ``--all``` - Виконання комміту стану з усіма змінами в робочому каталозі. Ця команда включає тільки зміни файлів, що відстежуються (тих, які були в якийсь момент додані в історію за допомогою команди git add).
* ```-m "commit message"```` - Швидка команда, яка створює коміт із зазначеним коментарем.

### Семантика коммітів
* [Вчимося писати правильні коментарі до комиту](https://habr.com/ru/company/otus/blog/537196/)
* [Conventional Commit Messages](https://gist.github.com/qoomon/5dfcdf8eec66a051ecd85625518cfd13)

<hr />

## ```git stash```
[Посилання](https://git-scm.com/docs/git-stash)

Команда git stash зберігає непідтверджені зміни (індексовані та неіндексовані) в окремому сховищі, щоб ви могли повернутися до них пізніше. Потім відбувається відкат до початкової робочої копії.

```git stash```

Щоб застосувати раніше відкладені зміни, скористайтеся командою ``git stash pop`` або ``git stash apply```

<hr />


## Скасування комітів

## ```git revert```
[Посилання](https://git-scm.com/docs/git-revert)


При виконанні ``git revert <commit>````git поверне стан робочої директорії без зазначеного комміту і запише його в новий коміт.

Це ідеальний спосіб скасування під час роботи у відкритих загальних репозиторіях, проте якщо у вас є вимога вести мінімальну «очищену» історію Git, ця стратегія може не підійти.

Щоб скасувати останній коміт можна використовувати ``git revert HEAD```


## ```git reset```
[Посилання](https://git-scm.com/docs/git-reset)

Команда git reset – це складний універсальний інструмент для скасування змін. Вона має три основні форми виклику, що відповідають аргументам командного рядка --soft, --mixed, --hard. Кожен із цих трьох аргументів відповідає трьом внутрішнім механізмам керування станом Git: дереву коммітів (HEAD), розділу проіндексованих файлів та робочому каталогу.

```git reset [<mode>] [<commit>]```

``[<commit>]``` - вказівник на певний коміт. Також можна передати замість ``[<commit>]``` назву гілки.

#### ``git reset``` видаляє коміти з дерева коммітів!

### Наприклад

```git reset --hard``` - скидає розділ проіндексованих файлів та робочий каталог до стану останнього комміту. Прапор --hard говорить Git, що потрібно не тільки скасувати зміни в розділі проіндексованих файлів, а й перезаписати всі зміни у робочому каталозі. Іншими словами, ця команда знищить усі ненаправлені зміни.

```git reset --hard origin/develop``` - скидає розділ проіндексованих файлів і робочий каталог до стану останнього комміта у віддаленій гілці develop.


### Резюме

* Команда ```git revert``` - найкращий інструмент для скасування загальних публічних змін.
* Команду ```git reset``` найкраще використовувати для скасування локальних приватних змін.
<hr />

# Командна робота в Git

## Синхронізація

## ```git fetch```
[Посилання](https://git-scm.com/docs/git-fetch)

Завантажує коміти, файли та посилання з віддаленого репозиторію у ваш локальний репозиторій.

Завантажити вміст із віддаленого репозиторію можна за допомогою двох команд: git pull та git fetch. З цих двох команд git fetch можна вважати безпечним варіантом. Вона завантажує віддалений вміст, але не оновлює робочий стан локального репозиторію, залишаючи поточну роботу недоторканою.

## ```git pull```
[Посилання](https://git-scm.com/docs/git-pull)

Завантажує коміти, файли та посилання з віддаленого репозиторію у ваш локальний репозиторій.

## ```git push```
[Посилання](https://git-scm.com/docs/git-push)

Публікація зазначеної гілки у віддаленому репозиторії разом із усіма необхідними комітами та внутрішніми об'єктами.

Git запобігає перезапису історії центрального репозиторію, відхиляючи push-запити, якщо не можна виконати їх прискорене злиття. Так, якщо історія віддаленого репозиторію відрізняється від вашої історії, необхідно завантажити віддалену гілку командою `git pull` а потім спробувати виконати команду `git push` ще раз.

Прапор `--force` скасовує цю поведінку та підганяє гілку віддаленого репозиторію під вашу локальну гілку, видаляючи будь-які вищі зміни, які могли бути внесені з моменту останнього виконання вами команди pull.
<hr />

## Злиття

## ```git merge```
[Посилання](https://git-scm.com/docs/git-merge)

Команда git merge поєднує кілька послідовностей коммітів у загальну історію. Найчастіше команду git merge використовують для об'єднання двох гілок.

```git merge <branch_name>```

### Підготовка до злиття
Перед злиттям слід зробити кілька підготовчих дій, щоб операція пройшла без проблем.

* Виконайте команду ```git status```. Це дозволить переконатися, що HEAD вказує на гілку, яка приймає результати злиття.
* За необхідності виконайте команду ````git checkout <приймаюча-гілка>```, щоб переключитися на гілку, що приймає.
* Переконайтеся, що в гілці, що приймає, і гілці для злиття містяться останні зміни з віддаленого репозиторію. Виконайте команду ``git fetch``, щоб отримати з нього останні комміти.
* Після вказаних вище дій з підготовки можете приступати до злиття. Для цього виконайте команду ```git merge <назва гілки>```, де <назва гілки> - назва гілки, яка буде об'єднана з приймаючою.

### Типи стратегій злиття в Git
_**Явне злиття**_ — стандартний варіант, який використовується за умовчанням. Злиття називається явним, тому що створюється новий коміт злиття. При цьому змінюється історія комміту та явно показано, де виконано злиття.
_**Приховане злиття**_ - з використанням методів "rebase" або "fast-forward".
<hr />

### Пара слів про ``git rebase```
[посилання] (https://www.atlassian.com/ru/git/tutorials/rewriting-history/git-rebase)
<hr />

### Пара слів про ``git squash```
<hr />


# Stylelint
[Посилання](https://stylelint.io/user-guide/get-started)

1. Встановлюємо stylelint ```npm install --save-dev stylelint```
2. Створюємо в кореневій папці файл "stylelintrc.json" і налаштовуємо його. Наприклад:
   ```json
   {
   "Рули": {
   "indentation": 2,
   "max-empty-lines": 1,
   "no-empty-first-line": true,
   "color-no-invalid-hex": true,
   "string-no-newline": true,
   "property-no-unknown": true,
   "block-no-empty": true,
   "selector-pseudo-class-no-unknown": true,
   "selector-pseudo-element-no-unknown": true,
   "media-feature-name-no-unknown": true,
   "comment-no-empty": true,
   "max-nesting-depth": 3,
   "string-quotes": "single"
   }
   }
   ````
3. Команда "npx stylelint "**/*.scss"" запустить перевірку всіх файлів.
3. Команда "npx stylelint "**/*.scss" --fix "" запустить автовиправлення всіх файлів.

# Husky & pre commit
[посилання](https://typicode.github.io/husky/#/)

1. npm install husky --save-dev
2. npx husky install
3. Додаємо в package.json скрипт попередньої установки husky:
   ``json
   {
   "scripts": {
   "prepare": "husky install"
   }
   }
   ````
4. husky add .husky/pre-commit "npm test" (де "test" - ім'я скрипта з package.json, який ви хочете запускати перед коммітом)
5. git add.