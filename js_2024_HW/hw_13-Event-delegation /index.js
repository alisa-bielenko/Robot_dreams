'use strict';

/* Теоретичні питання
1. Яке призначення методу event.preventDefault() у JavaScript?

Метод event.preventDefault() у JS використовується для скасування стандартної дії, 
яка зазвичай викликається подією. Коли ви прикріплюєте обробник подій до елемента 
на веб-сторінці (наприклад, обробник кліку чи відправлення форми), браузер виконує 
стандартну дію, пов'язану з цією подією.
Наприклад, якщо ви прикріплюєте обробник події до кнопки і ви хочете заборонити відправлення 
форми при кліку на кнопку без перезавантаження сторінки, ви можете використовувати 
event.preventDefault().

document.getElementById('myButton').addEventListener('click', function(event) {
    event.preventDefault(); // цей виклик запобігає стандартному дією (відправленню форми)
    // Ваш код для обробки події тут
});
Це дозволяє вам перехопити подію і виконати свою логіку обробки без того, щоб викликати 
стандартну дію, яка, наприклад, може включати перезавантаження сторінки або відправку форми.

2. В чому сенс прийому делегування подій?
Прийом делегування подій в JS полягає в тому, щоб прикріплювати один обробник подій 
до батьківського елемента, який містить декілька дочірніх елементів. Замість того, щоб 
прикріплювати обробник подій до кожного дочірнього елемента окремо, ви можете використовувати 
делегування для обробки подій, що спрощує код і зменшує кількість прикріплених обробників подій.

Ось деякі переваги делегування подій:
Ефективність пам'яті: Замість прикріплення обробників подій до кожного елемента окремо, 
ви прикріплюєте один обробник до батьківського елемента. Це може зменшити кількість 
об'єктів обробників в пам'яті і поліпшити продуктивність.
Динамічність: Якщо ви додаєте або видаляєте дочірні елементи динамічно, вам не потрібно 
переприкріплювати обробники подій для нових елементів. Однак обробка подій відбувається 
на батьківському елементі, і вона буде автоматично застосовуватися до нових дочірніх елементів.
Зручність коду: Код стає більш читабельним і організованим, оскільки вам не потрібно 
повторювати код для обробки подій на кожному окремому елементі.

Приклад:
// Без делегування
const buttons = document.querySelectorAll('.myButton');
buttons.forEach(button => {
    button.addEventListener('click', function() {
        // Обробка події для кожного елемента
    });
});

// З використанням делегування
const parentContainer = document.getElementById('parentContainer');
parentContainer.addEventListener('click', function(event) {
    if (event.target.classList.contains('myButton')) {
        // Обробка події лише для елементів з класом "myButton"
    }
});
У цьому прикладі подія відслідковується тільки на батьківському контейнері, 
але вона обробляється тільки для тих дочірніх елементів, які мають клас "myButton".

3. Які ви знаєте основні події документу та вікна браузера? 
Події документу:
- DOMContentLoaded: Спрацьовує, коли весь HTML та структура DOM були повністю завантажені 
та розібрані, не чекаючи завершення завантаження зовнішніх ресурсів (стилі, зображення, тощо).
- load: Спрацьовує, коли весь контент (включаючи зовнішні ресурси) був повністю завантажений.
- scroll: Спрацьовує при прокручуванні сторінки.

Події вікна браузера:
- resize: Спрацьовує при зміні розмірів вікна браузера.
- unload: Спрацьовує перед тим, як користувач покине сторінку або оновить її.
- beforeunload: Спрацьовує перед тим, як сторінка буде розривати з'єднання (наприклад, 
при спробі закрити вікно).


Практичне завдання:

Реалізувати перемикання вкладок (таби) на чистому Javascript.

Технічні вимоги:

- У папці tabs лежить розмітка для вкладок. Потрібно, щоб після натискання 
на вкладку відображався конкретний текст для потрібної вкладки. При цьому 
решта тексту повинна бути прихована. У коментарях зазначено, який текст 
має відображатися для якої вкладки.

- Розмітку можна змінювати, додавати потрібні класи, ID, атрибути, теги.
- Потрібно передбачити, що текст на вкладках може змінюватись, і що 
вкладки можуть додаватися та видалятися. При цьому потрібно, щоб функція, 
написана в джаваскрипті, через такі правки не переставала працювати.

 Умови:
 - При реалізації обов'язково використовуйте прийом 
 делегування подій (на весь скрипт обробник подій повинен бути один).

*/

const tabsContainer = document.querySelector('.tabs');
const tabContentCollection = document.querySelectorAll('.tabs-content li');
let activeTab = null;

tabsContainer.addEventListener('click', (event) => {
    activeTab?.classList.remove('active');
    activeTab = event.target;
    activeTab.classList.add('active');

    tabContentCollection.forEach(element => {
        if (element.className.includes('hidden')) {
            element.classList.remove('hidden');
        }
        if (activeTab.innerText !== element.dataset.content) {
            element.classList.add('hidden');
        }
    })
});